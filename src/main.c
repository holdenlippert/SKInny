#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "y.tab.h"
#include "main.h"
#include "dictionary.h"

/* Struct definitions: */

/**
 * Defines a linked list of bind/evaluate instructions. If the 'name' field is
 * NULL, the instruction is to evaluate 'expr'; otherwise the instruction is to
 * bind 'expr' to 'name'.
 */
struct instruction {
	char *name;
	struct ast *expr;
	struct instruction *next;
};

/**
 * Defines the AST structure of the program. Every node is either an
 * application or a symbol. If 'name' is null, then it represents an
 * application of 'function' onto 'argument'. If 'name' is not null, then it
 * represents a symbol with name 'name'.
 */
struct ast {
	char *name;
	struct ast *function;
	struct ast *argument;
};

/* Private function prototypes: */
static void			printtree(struct ast *);
static struct instruction *	getinstr();
static void			printinstr(struct instruction *instr);

/* Private global variables to keep track of the instruction queue: */
static struct instruction *first = NULL;
static struct instruction *last = NULL;

/* Private global variable to track bindings: */
static Dict bindings;

/*
 * Create a new AST node that represents the application of 'function' onto
 * 'argument'.
 */
struct ast *
node(struct ast *function, struct ast *argument)
{
	struct ast *ast = malloc(sizeof(struct ast));
	ast->name = NULL;
	ast->function = function;
	ast->argument = argument;
}

/*
 * Create a new AST node that represents the symbol with name 'name'.
 */
struct ast *
leaf(char *name)
{
	struct ast *ast = malloc(sizeof(struct ast));
	ast->name = strdup(name);
	ast->function = NULL;
	ast->argument = NULL;
}

/*
 * Print out the AST 'tree' in human readable form.
 */
void
printtree(struct ast *tree)
{
	if (tree->name != NULL)
		printf("%s", tree->name);
	else {
		printtree(tree->function);
		printf("(");
		printtree(tree->argument);
		printf(")");
	}
}

/*
 * Add an instruction to the instruction queue. If 'name' is null, it is an
 * evaluate instruction; otherwise it is a bind instruction.
 */
void
addinstr(char *name, struct ast *expr)
{
	struct instruction *new = malloc(sizeof(struct instruction));
	if (name != NULL)
		new->name = strdup(name);
	new->expr = expr;
	new->next = NULL;

	if (first == NULL)
		first = new;

	if (last == NULL)
		last = new;
	else {
		last->next = new;
		last = new;
	}
}

/*
 * Remove and return an instruction from the instruction queue.
 */
struct instruction *
getinstr()
{
	struct instruction *ret = first;
	first = first->next;
	return (ret);
}

/*
 * Print out a human readable interpretation of an instruction.
 */
void
printinstr(struct instruction *instr)
{
	if (instr->name != NULL) {
		printf("Bind %s to ", instr->name);
	}
	else {
		printf("Evaluate ");
	}
	printtree(instr->expr);
}

void
execute(struct instruction *instr)
{
	if (instr->name)
		insert(bindings, instr->name, instr->expr);
	else {
		printf("Evaluating ");
		printtree(instr->expr);
		printf("\n");
	}
}

int
main(int argc, char **argv) {
	// If there are two arguments, read from file instead of stdin:
	int fd;
	if (argc == 2)
		fd = open(argv[1], O_RDONLY);
	else
		fd = 0;
	if (fd < 0) {
		printf("Could not open file: %s\n", argv[1]);
		return (1);
	}
	dup2(fd, 0);

	bindings = emptydict();

	// Parse the program using code generated by yacc:
	yyparse();
	printf("finished parsing\n");

	// Print out the parsed code:
	while (first != NULL) {
		execute(getinstr());
	}

	printdict(bindings);

	return (0);
}
